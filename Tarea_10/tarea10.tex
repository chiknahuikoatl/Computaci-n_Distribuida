\documentclass[12pt,a4paper]{article}

%\usepackage[left=2cm, right=2cm, top=4cm, bottom=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{tikz}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\begin{document}

\begin{titlepage}
	\centering
	{\scshape\LARGE Universidad Nacional Autónoma de México \par}
	\vspace{1cm}
	{\scshape\Large Computación Distribuida\par}
	\vspace{1cm}
	{\huge\bfseries Algoritmos Autorregulables\par}
	\vspace{1cm}
    {\Large\itshape Jerónimo Almeida Rodríguez \par}
    \vspace{.5cm}
	{\Large\itshape Edgar Quiroz Castañeda \par}
    \vspace{.5cm}
	{\Large\itshape Naomi Reyes \dots \par}
	\vfill
	\includegraphics[width=0.5\textwidth]{escudo_f-ciencias.png}
	\vfill

	{\large Viernes 14 de Diciembre del 2018 \par}
\end{titlepage}

	\pagebreak
	\setlength{\voffset}{-0.75in}
	\setlength{\headsep}{5pt}


\begin{center}
		\textsc{\huge Algoritmos Autorregulables\\}
		\textit{Jerónimo Almeida, Edgar Quiroz, Naomi Reyes\\}
        14/12/2018
\end{center}

Los algoritmos Autorregulables son aquellos que, después de definido un estado
válido, todos los procesos que ejecuten dicho algoritmo tienden después de
algún tiempo a alcanzarlo sin importar el estado actual en el que se encuentren,
es decir, que pueden iniciar en cualquier estado arbitrario no válido o después
de que haya ocurrido algún error, el proceso llegue a un estado válido .



\section{Introducción}{
\subsection{Motivación}{
    Que el sistema se recupere de un error sin intervención humana, es decir que
    dado un estado global arbitrario (particularmente erróneo), dar un algoritmo
    que haga que el estado global eventualmente se vuelva válido.
}
\subsection{Especificación}{
    Texto de relleno
}
\subsection{Modelo}{}
}
\section{Pase de Token en un Anillo}{}
\section{Sincronizadores}{
    Después del error inicial, se puede considerar que no habrá más errores
    en el sistema. Entonces, el modelo es asícnrono sin fallas y se puede hacer
    todo lo mismo que en un modelo de este tipo, si bien se requieren algoritmos
    diferentes debido a las peculiaridades de comunicación del modelo.\\
    Una de las cosas que se puede hacer es un sincronizador.

    \subsection{Generalidades de sincronizadores}{
    Un sincronizador es algún programa que corre en paralelo al programa
    principal y permite determinar la ronda de comunicación en un momento dado
    en un sistema asíncrono. \\
    Con esto se puede asegurar que todos los procesos avancen sus rondas al
    mismo tiempo. Esto permite emular un sistema síncrono, pues si se sabe la
    ronda se puede garantizar que ningún proceso recibirá ningún mensaje de
    la ronda $r+1$ si algún otro proceso no ha enviado todas los mensajes de
    la ronda $r$.\\
    Hay dos tipos de sincronizadores. Puede ser globales, que sincronizan a
    toda la red. O pueden ser locales, que significan que sincronizan únicamente
    vecindades.\\
    Uno de los sincronizadores más simples es el sincronizador $\alpha$.
    }

    \subsection{Sincronizador $\alpha$}{
        La idea es que cada proceso avise a todos sus
        vecinos cuando pase a la siguiente ronda. Cuando un proceso recibe el
        aviso de ronda de todos sus entonces envía todos los mensajes de esa
        ronda, y pasa a la siguiente ronda.\\
        Puede pasar que un haya algún proceso $p_0$ ya haya enviado su aviso de
        ronda, pero que que aún no haya enviado todos los mensajes de la ronda
        $r$. Luego puede ser que algún $p_1 \in N(p_0)$ ya haya enviado todo y
        ya esté en la ronda $r+1$.\\
        $p_1$ no va a enviar ningún mensajes hasta que $p_0$ avise que ya avanzó de
        ronda, por lo que se respeta la regla de sinronización, pero las rondas
        de $p_0$ y $p_1$ difieren en 1.\\
        De esto, vemos que $\alpha$ es un sincronizador local.
        Y, en general, hay que notar que en cualquier momento cualesquiera dos nodos
        difieren a los más en una ronda.
    }

    \subsection{Sincronizador autorregulable}{
        La idea de un sincronizador autoregulable es que cada proceso comience
        con alguna ronda arbitraria, y que eventualmente se llegue y se
        permanezca en un estado válido para un sincronizador $\alpha$.\\
        Como en el modelo el estado de cada proceso es público para sus vecinos,
        no es necesario enviar mensajes al cambiar de ronda.\\
        Entonces, de las especificaciones del sincronizador $\alpha$, se tiene
        que lo único que un estado válido debe cumplir es que para todo par de
        procesos adyacentes, sus rondas difieran a lo más en 1.
    }

        \subsubsection{Regla Simple}{
        Intuitivamente, si los estados de los procesos son públicos para sus
        vecinos, lo más sencillo para ponerse de acuerdo en algún valor para la
        ronda sería tomar el mínimo.\\
        Pero esto generaría que los procesos se estanquen en ese mínimo, pues en
        cuanto algún otro proceso cmabie de ronda, inmediatamente volvería a ese
        mínimo.\\
        Y por la naturaleza del modelo, no es posible saber localmente cuando ya
        se llegó a un estado válido en el sistema.\\
        Entonces se puede siempre aumentar 1 a aquel mínimo en cada paso y
        esperar que eventualmente converga a un estado válido.\\
        La regla es entonces
        \[P(v) \leftarrow min_{w \in N(v)}(P(w)) + 1\]
        Pero lamentablemente un estado arbitrario no siempre converge a un estado
        válido.\\
        Consideremos el anillo $C = (1, 2, 3, 4, 3, 1)$, que por simplidad
        vamos a representar como 12343.\\
        Iniciando en 2 y ejecutando los procesos en sentido horario tenemos que
        \begin{align*}
            &1\textbf{2}343 \\
            &12\textbf{3}43 \\
            &123\textbf{4}3 \\
            &1234\textbf{2} \\
            &\textbf{3}2342 \\
            &3\textbf{4}342 \\
            &34\textbf{5}42
        \end{align*}
        Entonces se llega al anillo $C_2 = (3, 4, 5, 4, 2, 3)$ que si se representa
        iniciando en 2 es $C_2 = (2, 3, 4, 5, 4, 2)$ que es exactamente el mismo
        anillo que al inicio, si se aumenta 1 a cada nodo.\\
        Es decir, en este caso específico, el algoritmo eventualmente vuelve al
        inválido estado inicial.
        }

        \subsubsection{Segunda Regla}{
        El problema de la regla anterior es que
        }

        \subsubsection{Regla Óptima}{}
}
\section{Conclusión}{}

\begin{thebibliography}{}

\bibitem[Asp18]{Asp18}
James Aspnes. Notes on Theory of Distributed Systems.
\href{http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf}
{http://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf}, October 2018.

\end{thebibliography}
\end{document}
